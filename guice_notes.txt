##########
# basics
##########

- Create a class to extend AbstractModule and override configure()
provide bind() method to map interface or parent class to concrete implementation or subclass

- in the main(), create Injector
Injector injector = Guice.createInjector(new AppModule());

- with Interface reference, can use injector to get actual object
SquareRequestCI r = injector.getInstance(SquareRequestCI.class);

- for the constructor injection, should be annotated with @Inject
@Inject
public SquareRequestCI(DrawShape d) {
    this.d = d;
}

- binding can also be done on String or Integer, for ex:
bind(String.class).toInstance("Red");
bind(Integer.class).toInstance(40);

- however, better way is to create an annotation
bind(String.class).annotatedWith(ColorValue.class).toInstance("Red");
bind(Integer.class).annotatedWith(EdgeValue.class).toInstance(40);

- guice creates Object Graph for all the dependencies binded in AbstractModule

- create a singleton
bind(SquareRequestCI.class).to(SquareRequestSub.class).in(Scopes.SINGLETON);

####################
# ways of injections
####################

- same as Spring - can inject using
Constructor, Method setter, or directly on field member


##################################################
# 2 concrete implementations of the same interface
##################################################

- to chose one, annotations can be used same as above for Color and edge

bind(DrawShape.class).annotatedWith(Square.class).to(DrawSquare.class);
bind(DrawShape.class).annotatedWith(Circle.class).to(DrawCircle.class);

now that annotation can be used wherever we are using @Inject

###################
# Named annotations
###################

- instead of using our own annotation, can use Named annotations
- we dont need to create our annotations
- best practice is not to use named annotations

bind(DrawShape.class).annotatedWith(Names.named("Square")).to(DrawSquare.class);
bind(DrawShape.class).annotatedWith(Names.named("Circle")).to(DrawCircle.class);

@Inject
public CircleRequest(@Named("Circle") DrawShape drawShape) {
        this.drawShape = drawShape;
}


#################################################
# Creating complex objects with @Provide methods
#################################################

- Complex objects means creating objects not using default constructor
- if we can not use @Inject as its a third party jar
- as there is no default constructor, we can not use bind method in AppModule configure()
- instead we can provide a custom method in AppModule and annotate with @Provides

@Provides
DrawShape providesDrawSquare() {
        DrawShape d = new DrawSquare("Red", 40);
        return d;
}

- use @Singleton to provide singleton
@Provides
@Singleton
DrawShape providesDrawSquare() {

- arguments can be again annotated and bind()
@Provides
@Singleton
DrawShape providesDrawSquare(@ColorValue String color, @EdgeSize Integer edge) {
        DrawShape d = new DrawSquare(color, edge);
        return d;
}


- if we have multiple implementations of DrawShape - like DrawCircle and DrawSquare
- need to create separate annotations and add it to provider methods in AppModule


#################################################
# Creating complex objects with Provider classes
#################################################
- instead of using annotations @Provides in AppModule class, we can create separate Provider class
- in the bind() method, provide Provider class binding
- example:
bind(DrawShape.class).toProvider(DrawShapeProvider.class);

- everything done as annotation can be mapped in Provider class
- for getting particular concrete class, always use annotations
- example:
        bind(DrawShape.class).annotatedWith(Square.class).toProvider(DrawSquareProvider.class).in(Scopes.SINGLETON);
        bind(String.class).annotatedWith(SquareColorValue.class).toInstance("Red");
        bind(Integer.class).annotatedWith(EdgeSize.class).toInstance(40);

        bind(DrawShape.class).annotatedWith(Circle.class).toProvider(DrawCircleProvider.class).in(Scopes.SINGLETON);
        bind(String.class).annotatedWith(CircleColorValue.class).toInstance("Blue");
        bind(Integer.class).annotatedWith(Radius.class).toInstance(5);
-

#################################
# Injecting using Provider class
#################################
- whenever guice tries to create a object, it looks for default constructor first
- if no default constructor present, it will look for other constructors => but it should be @Inject
- example
private final Provider<DrawSquare> squareProvider;

- whenever get() method is called, guice will try to create <DrawSquare> object
DrawSquare d1 = squareProvider.get();

- this mechanism helps to create any number of objects as needed


