# basics

- Create a class to extend AbstractModule and override configure()
provide bind() method to map interface or parent class to concrete implementation or subclass

- in the main(), create Injector
Injector injector = Guice.createInjector(new AppModule());

- with Interface reference, can use injector to get actual object
SquareRequestCI r = injector.getInstance(SquareRequestCI.class);

- for the constructor injection, should be annotated with @Inject
@Inject
public SquareRequestCI(DrawShape d) {
    this.d = d;
}

- binding can also be done on String or Integer, for ex:
bind(String.class).toInstance("Red");
bind(Integer.class).toInstance(40);

- however, better way is to create an annotation
bind(String.class).annotatedWith(ColorValue.class).toInstance("Red");
bind(Integer.class).annotatedWith(EdgeValue.class).toInstance(40);

- guice creates Object Graph for all the dependencies binded in AbstractModule

- create a singleton
bind(SquareRequestCI.class).to(SquareRequestSub.class).in(Scopes.SINGLETON);

# ways of injections
- same as Spring - can inject using 
Constructor, Method setter, or directly on field member

# 2 concrete implementations of the same interface
- to chose one, annotations can be used same as above for Color and edge

bind(DrawShape.class).annotatedWith(Square.class).to(DrawSquare.class);
bind(DrawShape.class).annotatedWith(Circle.class).to(DrawCircle.class); 

now that annotation can be used wherever we are using @Inject

