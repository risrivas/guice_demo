##########
# basics
##########

- Create a class to extend AbstractModule and override configure()
provide bind() method to map interface or parent class to concrete implementation or subclass

- in the main(), create Injector
Injector injector = Guice.createInjector(new AppModule());

- with Interface reference, can use injector to get actual object
SquareRequestCI r = injector.getInstance(SquareRequestCI.class);

- for the constructor injection, should be annotated with @Inject
@Inject
public SquareRequestCI(DrawShape d) {
    this.d = d;
}

- binding can also be done on String or Integer, for ex:
bind(String.class).toInstance("Red");
bind(Integer.class).toInstance(40);

- however, better way is to create an annotation
bind(String.class).annotatedWith(ColorValue.class).toInstance("Red");
bind(Integer.class).annotatedWith(EdgeValue.class).toInstance(40);

- guice creates Object Graph for all the dependencies binded in AbstractModule

- create a singleton
bind(SquareRequestCI.class).to(SquareRequestSub.class).in(Scopes.SINGLETON);

####################
# ways of injections
####################

- same as Spring - can inject using 
Constructor, Method setter, or directly on field member


##################################################
# 2 concrete implementations of the same interface
##################################################

- to chose one, annotations can be used same as above for Color and edge

bind(DrawShape.class).annotatedWith(Square.class).to(DrawSquare.class);
bind(DrawShape.class).annotatedWith(Circle.class).to(DrawCircle.class); 

now that annotation can be used wherever we are using @Inject

###################
# Named annotations
###################

- instead of using our own annotation, can use Named annotations 
- we dont need to create our annotations
- best practice is not to use named annotations

bind(DrawShape.class).annotatedWith(Names.named("Square")).to(DrawSquare.class);
bind(DrawShape.class).annotatedWith(Names.named("Circle")).to(DrawCircle.class);

@Inject
public CircleRequest(@Named("Circle") DrawShape drawShape) {
        this.drawShape = drawShape;
}


###################
# Creating complex objects with @Provide methods
###################

- if we can not use @Inject as its a third party jar
- as there is no default constructor, we can not use bind method in AppModule configure()
- instead we can provide a custom method in AppModule and annotate with @Provides

@Provides
DrawShape providesDrawSquare() {
        DrawShape d = new DrawSquare("Red", 40);
        return d;
}

- use @Singleton to provide singleton
@Provides
@Singleton
DrawShape providesDrawSquare() {

- arguments can be again annotated and bind() 
@Provides
@Singleton
DrawShape providesDrawSquare(@ColorValue String color, @EdgeSize Integer edge) {
        DrawShape d = new DrawSquare(color, edge);
        return d;
}


